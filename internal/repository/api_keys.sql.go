// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: api_keys.sql

package repository

import (
	"context"
	"database/sql"
)

const createApiKey = `-- name: CreateApiKey :exec
INSERT INTO api_keys (
    value, application
) VALUES (
    ?, ?
)
`

type CreateApiKeyParams struct {
	Value       string `json:"value"`
	Application string `json:"application"`
}

func (q *Queries) CreateApiKey(ctx context.Context, db DBTX, arg CreateApiKeyParams) error {
	_, err := db.ExecContext(ctx, createApiKey, arg.Value, arg.Application)
	return err
}

const getApiKeyByValue = `-- name: GetApiKeyByValue :one
SELECT id FROM api_keys WHERE api_keys.value = ?
`

func (q *Queries) GetApiKeyByValue(ctx context.Context, db DBTX, value string) (int64, error) {
	row := db.QueryRowContext(ctx, getApiKeyByValue, value)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const listApiKeys = `-- name: ListApiKeys :many
SELECT id, value, created_at, updated_at, revoked_at FROM api_keys
`

type ListApiKeysRow struct {
	ID        int64          `json:"id"`
	Value     string         `json:"value"`
	CreatedAt string         `json:"created_at"`
	UpdatedAt string         `json:"updated_at"`
	RevokedAt sql.NullString `json:"revoked_at"`
}

func (q *Queries) ListApiKeys(ctx context.Context, db DBTX) ([]ListApiKeysRow, error) {
	rows, err := db.QueryContext(ctx, listApiKeys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListApiKeysRow
	for rows.Next() {
		var i ListApiKeysRow
		if err := rows.Scan(
			&i.ID,
			&i.Value,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RevokedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
